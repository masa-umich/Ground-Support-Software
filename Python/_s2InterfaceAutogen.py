### BEGIN AUTOGENERATED SECTION - MODIFICATIONS TO THIS CODE WILL BE OVERWRITTEN

### _s2InterfaceAutogen.py
### Autogenerated by firmware-libraries/SerialComms/python/cmd_file_generator.py on Wed Dec 30 17:59:40 2020

import serial

class _S2_InterfaceAutogen:
	def __init__(self):
		# A dictionary mapping command name to packet_type (command ID)
		self.cmd_names_dict = {
			"set_vlv"	:	8,
			"send_telem_short"	:	9,
			"send_telem_all"	:	10,
			"set_stepper_period"	:	11,
			"set_stepper_direction"	:	12,
			"set_kp"	:	13,
			"set_ki"	:	14,
			"set_kd"	:	15,
			"set_control_calc_period"	:	16,
			"set_state"	:	17,
			"move_stepper_degrees"	:	18
		}

		# A dictionary mapping packet_type (command ID) to a list of function argument information.
		# The nth tuple in each list corresponds to the nth argument for that command's function,
		# in the order (arg_name, arg_type, xmit_scale)
		self.cmd_args_dict = {
			8	:	[('vlv_num', 'uint32_t', 1), ('state', 'uint8_t', 1)],
			9	:	[('board_num', 'uint8_t', 1)],
			10	:	[('board_num', 'uint8_t', 1)],
			11	:	[('stepper_num', 'uint8_t', 1), ('period', 'uint16_t', 1)],
			12	:	[('stepper_num', 'uint8_t', 1), ('direction', 'int8_t', 1)],
			13	:	[('motor_num', 'uint8_t', 1), ('gain', 'double', 100)],
			14	:	[('motor_num', 'uint8_t', 1), ('gain', 'double', 100)],
			15	:	[('motor_num', 'uint8_t', 1), ('gain', 'double', 100)],
			16	:	[('period', 'uint16_t', 1)],
			17	:	[('state', 'uint8_t', 1)],
			18	:	[('motor_num', 'uint8_t', 1), ('deg', 'uint16_t', 1)]
		}

	"""
	Encodes command info and arguments with COBS and transmits them over serial
	@params
		ser (pyserial object)  - serial obejct to write to
		cmd_info (dict)        - dictionary with the following key value pairs:
			"function_name" : function name (string)
			"target_board_addr" : address of board to send command to (integer)
			"timestamp" : time the command was sent (integer)
			"args" : list of arguments to send to the function (list)
	"""
	def s2_command(self, ser, cmd_info):
		#Initialize empty packet
		packet = list()

		#Fill first 10 bytes of packet with CLB packet header information
		packet.append(self.cmd_names_dict[cmd_info["function_name"]])	# packet_type)
		packet.append(cmd_info["target_board_addr"])	# target_addr
		packet.append(1)	# priority
		packet.append(1)	# do_cobbs
		packet.append(0)	# checksum
		packet.append(0)	# checksum
		packet.append((cmd_info["timestamp"] >> 24) & 0xFF)	# timestamp
		packet.append((cmd_info["timestamp"] >> 16) & 0xFF)	# timestamp
		packet.append((cmd_info["timestamp"] >> 8) & 0xFF)	# timestamp
		packet.append((cmd_info["timestamp"] >> 0) & 0xFF)	# timestamp

		# Stuff packet with the function arguments according to the packet_type ID
		command_id = self.cmd_names_dict[cmd_info["function_name"]]
		# set_vlv()
		if (command_id == 8):
			# vlv_num
			packet.append(((cmd_info["args"][0]*1) >> 0) & 0xFF)
			packet.append(((cmd_info["args"][0]*1) >> 8) & 0xFF)
			packet.append(((cmd_info["args"][0]*1) >> 16) & 0xFF)
			packet.append(((cmd_info["args"][0]*1) >> 24) & 0xFF)
			# state
			packet.append(((cmd_info["args"][1]*1) >> 0) & 0xFF)
		# send_telem_short()
		elif (command_id == 9):
			# board_num
			packet.append(((cmd_info["args"][0]*1) >> 0) & 0xFF)
		# send_telem_all()
		elif (command_id == 10):
			# board_num
			packet.append(((cmd_info["args"][0]*1) >> 0) & 0xFF)
		# set_stepper_period()
		elif (command_id == 11):
			# stepper_num
			packet.append(((cmd_info["args"][0]*1) >> 0) & 0xFF)
			# period
			packet.append(((cmd_info["args"][1]*1) >> 0) & 0xFF)
			packet.append(((cmd_info["args"][1]*1) >> 8) & 0xFF)
		# set_stepper_direction()
		elif (command_id == 12):
			# stepper_num
			packet.append(((cmd_info["args"][0]*1) >> 0) & 0xFF)
			# direction
			packet.append(((cmd_info["args"][1]*1) >> 0) & 0xFF)
		# set_kp()
		elif (command_id == 13):
			# motor_num
			packet.append(((cmd_info["args"][0]*1) >> 0) & 0xFF)
			# gain
			packet.append(((cmd_info["args"][1]*100) >> 0) & 0xFF)
			packet.append(((cmd_info["args"][1]*100) >> 8) & 0xFF)
			packet.append(((cmd_info["args"][1]*100) >> 16) & 0xFF)
			packet.append(((cmd_info["args"][1]*100) >> 24) & 0xFF)
			packet.append(((cmd_info["args"][1]*100) >> 32) & 0xFF)
			packet.append(((cmd_info["args"][1]*100) >> 40) & 0xFF)
			packet.append(((cmd_info["args"][1]*100) >> 48) & 0xFF)
			packet.append(((cmd_info["args"][1]*100) >> 56) & 0xFF)
		# set_ki()
		elif (command_id == 14):
			# motor_num
			packet.append(((cmd_info["args"][0]*1) >> 0) & 0xFF)
			# gain
			packet.append(((cmd_info["args"][1]*100) >> 0) & 0xFF)
			packet.append(((cmd_info["args"][1]*100) >> 8) & 0xFF)
			packet.append(((cmd_info["args"][1]*100) >> 16) & 0xFF)
			packet.append(((cmd_info["args"][1]*100) >> 24) & 0xFF)
			packet.append(((cmd_info["args"][1]*100) >> 32) & 0xFF)
			packet.append(((cmd_info["args"][1]*100) >> 40) & 0xFF)
			packet.append(((cmd_info["args"][1]*100) >> 48) & 0xFF)
			packet.append(((cmd_info["args"][1]*100) >> 56) & 0xFF)
		# set_kd()
		elif (command_id == 15):
			# motor_num
			packet.append(((cmd_info["args"][0]*1) >> 0) & 0xFF)
			# gain
			packet.append(((cmd_info["args"][1]*100) >> 0) & 0xFF)
			packet.append(((cmd_info["args"][1]*100) >> 8) & 0xFF)
			packet.append(((cmd_info["args"][1]*100) >> 16) & 0xFF)
			packet.append(((cmd_info["args"][1]*100) >> 24) & 0xFF)
			packet.append(((cmd_info["args"][1]*100) >> 32) & 0xFF)
			packet.append(((cmd_info["args"][1]*100) >> 40) & 0xFF)
			packet.append(((cmd_info["args"][1]*100) >> 48) & 0xFF)
			packet.append(((cmd_info["args"][1]*100) >> 56) & 0xFF)
		# set_control_calc_period()
		elif (command_id == 16):
			# period
			packet.append(((cmd_info["args"][0]*1) >> 0) & 0xFF)
			packet.append(((cmd_info["args"][0]*1) >> 8) & 0xFF)
		# set_state()
		elif (command_id == 17):
			# state
			packet.append(((cmd_info["args"][0]*1) >> 0) & 0xFF)
		# move_stepper_degrees()
		elif (command_id == 18):
			# motor_num
			packet.append(((cmd_info["args"][0]*1) >> 0) & 0xFF)
			# deg
			packet.append(((cmd_info["args"][1]*1) >> 0) & 0xFF)
			packet.append(((cmd_info["args"][1]*1) >> 8) & 0xFF)

		# Encode the packet with COBS
		stuff_array(packet)

		# Set the packet length to 255
		if (len(packet) < 255):
			packet += [0]*(255 - len(packet))

		# Write the bytes to serial
		ser.write(bytes(packet))

	"""
	Takes in a byte packet and return a COBS encoded version
	Note: this was copied directly from the EC3 gui code
	@params
		arr (integer array)  - Byte packet to be COBS encoded
		separator (integer)  - Packet delimiter. Should be using 0, but has the option to use any number
	"""
	def stuff_array(self, arr, separator=0):
		arr.append(0)
		arr.insert(0, 0)
		first_sep = 1
		for x in arr[1:]:
			if x == separator:
				break
			first_sep += 1
		index = 1
		while(index < len(arr)-1):
			if(arr[index] == separator):
				offset = 1
				while(arr[index+offset] != separator):
					offset += 1
				arr[index] = offset
				index += offset
			else:
				index += 1
		arr[0] = first_sep
		return arr

